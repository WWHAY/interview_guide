# 切片
对于字符串的处理也经常可以看做数组的处理，因为两者在处理上方法几乎是一致的；

其实切片就是数组，对与数组来说通常有的算法：
1. 排序
2. 查找
常用的算法是：
1. 迭代
2. 递归
3. 双指针
5. 滑动窗口 
6. 快慢指针
7. 滚动数组

# 回溯&剪枝&深度优先搜索
回溯的思想其实就是递归，一个大问题可以转换成无数的小问题去求解，不撞南墙不回头（递归的终止条件），回头的过程中，可能存在着剪枝，避免再次回溯，去除无用的搜索
和深度优先遍历很像，搜寻节点，知道节点为nil，在回头。
## 与动态规划的区别
### 相同点
1. 都是将大问题转化成为小问题，阶段求解
2. 每一个步骤都有多个选择
### 不相同的点
1. 动态规划，一般是强调的是最优解，一般不考虑具体的解是什么
2. 回溯是搜索算法，搜索所有的答案，包括最优解，所以时间复杂度是很高的
## 求解过程
每一个结点表示了求解全排列问题的不同的阶段，这些阶段通过变量的「不同的值」体现，这些变量的不同的值，称之为「状态」；
使用深度优先遍历有「回头」的过程，在「回头」以后， 状态变量需要设置成为和先前一样 ，因此在回到上一层结点的过程中，需要撤销上一次的选择，这个操作称之为「状态重置」；
深度优先遍历，借助系统栈空间，保存所需要的状态变量，在编码中只需要注意遍历到相应的结点的时候，状态变量的值是正确的，具体的做法是：往下走一层的时候，path 变量在尾部追加，而往回走的时候，需要撤销上一次的选择，也是在尾部操作，因此 path 变量是一个栈；
深度优先遍历通过「回溯」操作，实现了全局使用一份状态变量的效果。
1. 状态变量设置
2. 存储
3. 回退
## 回溯求解总结
1. 定义最终的结果变量，定义临时数组，定义递归函数，定义状态变量
2. 确定递归函数内容，修改状态变量，更新临时数组
3. 递归终止条件满足之后，将临时数组加入到结果数组中
### 临时数组加入结果数组的方式
1. append新增的一个临时数组，一般是[][]二维数组，防止临时数组改变会对原始数组的值有误差的
2. 直接append原始的临时数组，一般结果是一维数组，可以直接在原始结果上修改的
字符串是值变量，[]stirng是指针变量的区别

### 枚举（N皇后的问题）
1. 子集枚举：从n的格子中，选择不在用干一行，不在同一列，不在同一对角线的
2. 组合枚举：*n的格子中，选择n个元素，n个元素任一两个都不在同一行，同一列，同一对角线
3. 排列枚举：n行中防止一个皇后，而皇后的列号构成了n的排列
```golang
func subsets(nums []int) (ans [][]int) {
    // 临时变量
    set := []int{}
    var dfs func (cur int)
    // 递归函数
    dfs = func (cur int){
        // 递归终止条件
        if cur == len(nums){
            // 切片是指针传递，将切片的元素传给ans，所以声明了一个空数组
            ans = append(ans, append([]int{},set...))
            return
        }
        // 增加临时变量
        set = append(set,nums[cur])
        // 递归
        dfs(cur+1)
        // 撤销
        set = set[:len(set)-1]
        dfs(cur+1)
    }
    dfs(0)
    return ans
}

```